---
title: Віддалені сховища в GitHub
teaching: 45
exercises: 0
questions:
- "Як поділитися своїми змінами з іншими в мережі?"
objectives:
- "Пояснення, що таке віддалені репозиторії і чому вони корисні."
- "Відправляти зміни до віддаленого репозиторію або отрмимувати зміни з нього."
keypoints:
- "Локальний репозиторій Git можна підключити до одного або декількох віддалених репозиторіїв."
- "Використання протоколу SSH для підключення до віддалених репозиторіїв."
- "`git push` копіює зміни з локального репозиторію до віддаленого репозиторію."
- "`git pull` копіює зміни з віддаленого репозиторію в локальний репозиторій."
---

Контроль версій дійсно вступає в свою силу, коли ми починаємо співпрацювати з
іншими людьми. У нас вже є велика частина техніки, яка нам потрібна для цього;
єдине, чого не вистачає - копіювати зміни з одного репозиторію в інший.

Такі системи, як Git, дозволяють переміщати роботу між будь-якими двома репозиторіями.
Однак, практично найпростіше використовувати одну копію в якості центрального вузла, і зберегти його
в мережі, аніж на чиємусь ноутбуці. Багато програмістів використовують хостинг сервіси, такі як
[GitHub](https://github.com), [Bitbucket](https://bitbucket.org) або
[GitLab](https://gitlab.com/) щоб зберігати основні копії; ми вивчимо плюси
та мінуси цього в іншому епізоді.

Почнемо з обміну змінами, які ми внесли до нашого поточного проєкту зі
світом. З цією метою ми збираємося створити *віддалений* репозиторій, який буде пов'язаний з нашим *локальним* репозиторієм.

## 1. Створіть віддалений репозиторій
Увійдіть до [GitHub](https://github.com), потім натисніть на значок у верхньому правому куті, щоб
створити новий репозиторій під назвою `planets`:

![Створення репозиторію у GitHub (Крок 1)]({{ site.baseurl }}/fig/github-create-repo-01.png)

Назвіть ваш репозиторій "planets" і потім натисніть на "Create Repository".

Зауважте: Оскільки цей репозиторій буде підʼєднано до локального репозиторію, він має бути порожнім. Залиште 
"Initialize this repository with a README" непозначеним, та залиште "None" як опції для обох "Add 
.gitignore" та "Add a license." Ознайомтеся із вправою "GitHub License and README files" нижче для повного
пояснення чому репозиторій повинен бути порожнім.

![Створення репозиторію у GitHub (Крок 2)]({{ site.baseurl }}/fig/github-create-repo-02.png)

Як тільки репозиторій створено, GitHub відображає сторінку з URL і певною
інформацією про те, як налаштувати локальний репозиторій:

![Створення репозиторію у GitHub (Крок 3)]({{ site.baseurl }}/fig/github-create-repo-03.png)

Це ефективно робить наступне на серверах GitHub:

~~~
$ mkdir planets
$ cd planets
$ git init
~~~
{: .language-bash}

Якщо ви пам'ятаєте, у одному з попередніх [епізодів](../04-changes/), де ми додавали та
зберігали нашу попередню роботу над `mars.txt`, в нас була діаграма, яка зображувала локальний репозиторій,
та виглядала так:

![Локальний репозиторій із зоною стейджингу]({{ site.baseurl }}/fig/git-staging-area.svg)

Тепер, коли ми маємо два репозиторії, нам потрібна така діаграма:

![Freshly-Made GitHub Repository]({{ site.baseurl }}/fig/git-freshly-made-github-repo.svg)

Зауважте, що наш локальний репозиторій все ще містить нашу попередню роботу над `mars.txt`, але
віддалений репозиторій на GitHub зображується порожнім, оскільки він ще не містить жодних файлів.

## 2. Підʼєднання локального репозиторію до віддаленого
Тепер підключаємо два сховища. Ми можемо це зробити за допомогою
GitHub репозиторію [remote]({{ page.root}}{% link reference.md %}#remote) для локального репозиторію.
Домашня сторінка репозиторію на GitHub включає рядок URL, який нам потрібен
щоб ідентифікувати його:

![Where to Find Repository URL on GitHub]({{ site.baseurl }}/fig/github-find-repo-string.png)

Натисніть на посилання 'SSH', щоб змінити [protocol]({{ page.root }}{% link reference.md %}#protocol) від HTTPS до SSH.

> ## HTTPS в порівнянні з SSH
>
> Ми тут використовуємо SSH тому що, поки він вимагає додаткову конфігурацію, це 
> протокол безпеки, який широко використовується багатьма програмами.  Кроки нижче описують SSH на 
> мінімальному рівні GitHub. Додатковий епізод до цього уроку обговорює розширені налаштування 
> і концепції SSH і пари ключів, а також інші матеріали, що доповнюють git пов'язані SSH. 
{: .callout}

![Changing the Repository URL on GitHub]({{ site.baseurl }}/fig/github-change-repo-string.png)

Скопіюйте цю URL-адресу з браузера, зайдіть в локальне сховище `planets` репозиторію, та запустіть
цю команду:

~~~
$ git remote add origin git@github.com:vlad/planets.git
~~~
{: .language-bash}

Переконайтеся, що використовуєте URL-адресу для вашого сховища, а нет Vlad's: єдиною
відмінністю має бути ваше ім'я користувача замість `vlad`.

`origin` - локальна назва, що використовується для позначення віддаленого репозиторію. Його модна було б назвати
як завгодно, але `origin` - це конвенція, яка часто використовується за замовчуванням в git
та GitHub, так що корисно дотримуватися цього, якщо немає особливої причини змінювати.

Ми можемо перевірити, що команда працювала, запустивши `git remote -v`:

~~~
$ git remote -v
~~~
{: .language-bash}

~~~
origin   git@github.com:vlad/planets.git (fetch)
origin   git@github.com:vlad/planets.git (push)
~~~
{: .output}

Більш детально ми обговоримо віддалені файли в наступному епізоді, поки поговоримо про те,
як вони можуть бути використані для співпраці.

## 3. SSH Фон та Налаштування
Перед тим, як Dracula може під`єднатися до віддаленого репозиторію, йому потрібно налаштувати спосіб автентифікації свого комп'ютера за допомогою GitHub, щоб він знав, що це він намагається під`єднатися до його віддаленого репозиторію. 

Ми збираємося налаштувати метод, який зазвичай використовується багатьма різними службами для автентифікації доступу в командному рядку. Цей метод називається Secure Shell Protocol (SSH).  SSH це протокол криптографічної мережі, який дозволяє безпечний зв'язок між комп'ютерами за допомогою використання іншої небезпечної мережі.  

SSH використовує те, що називається ключовою парою. Це два ключі, які працюють разом для перевірки доступу. Один ключ публічно відомий і називається відкритим ключем, а інший - приватним ключем. Дуже описові назви.

Ви можете думати про відкритий ключ як замок, і тільки у вас є ключ (приватний ключ), щоб відчинити його. Ви використовуєте відкритий ключ, де ви хочете безпечний спосіб зв'язку, наприклад, ваш GitHub акаунт.  Ви даєте цей висячий замок або відкритий ключ GitHub і говорите: "Заблокувати повідомлення до мого облікового запису, так що тільки комп'ютери, які мають мій закритий ключ можуть розблокувати зв'язок і відправити git команди, як мій GitHub акаунт.”  

Те, що ми будемо робити зараз, це мінімум, необхідний для налаштування SSH-ключів і додавання відкритого ключа до GitHub акаунту.

> ## Розширений SSH
> Додатковий епізод в цьому уроці обговорює SSH і ключові пари більш глибоко і детально. 
{: .callout}

Перше, що ми збираємося зробити, це перевірити, чи це вже зроблено на комп'ютері, на якому ви працюєте зараз.  Тому що взагалі кажучи, ця установка повинна відбутися тільки один раз, і тоді ви можете забути про це. 

> ## Дотримання ключів захищеними
> Ви не повинні забувати про ваші SSH ключі, так як вони тримають ваш обліковий запис в безпеці. Це хороша
>  практика перевіряти захищені ключі shell. Особливо, якщо ви використовуєте кілька
>  комп'ютерів для доступу до облікового запису.
{: .callout}

Ми запустимо команду списку (list - ls), щоб перевірити, які пари ключів вже існують на вашому комп'ютері.

~~~
ls -al ~/.ssh
~~~
{: .language-bash}

Ваш результат буде виглядати трохи інакше в залежності від того, чи був коли-небудь SSH встановлений на комп'ютері, який ви використовуєте чи ні.

Dracula не налаштував SSH на його комп`ютері, тож його результат виглядає так

~~~
ls: cannot access '/c/Users/Vlad Dracula/.ssh': No such file or directory
~~~
{: .output}

Якщо SSH було встановлено на комп'ютері, який ви використовуєте, пари відкритих і приватних ключів будуть перераховані. Назви файлів будуть або `id_ed25519`/`id_ed25519.pub`, або `id_rsa`/`id_rsa.pub` залежно від того, як були створені пари ключів.  
Так як вони не існують на комп`ютері Dracula, він використовує цюкоманду, щоб створити їх. 

### 3.1 Створення пари ключів SSH
Для створення пари ключів SSH Vlad використовує цю команду, де параметр `-t` визначає який тип алгоритму використати, та `-C` прикріплює коментар до ключа (тут електронна пошта Vlad):  

~~~
$ ssh-keygen -t ed25519 -C "vlad@tran.sylvan.ia"
~~~
{: .language-bash}

Якщо ви використовуєте застарілу систему, яка не підтримує Ed25519 алгоритм, використовуйте:
`$ ssh-keygen -t rsa -b 4096 -C "your_email@example.com"`

~~~
Generating public/private ed25519 key pair.
Enter file in which to save the key (/c/Users/Vlad Dracula/.ssh/id_ed25519):
~~~
{: .output}

Ми хочемо використовувати типовий файл, тому просто натисніть <kbd>Enter</kbd>.

~~~
Created directory '/c/Users/Vlad Dracula/.ssh'.
Enter passphrase (empty for no passphrase):
~~~
{: .output}

Тепер це спонукає Dracula до пароля.  Оскільки він використовує ноутбук своєї лабораторії, до якого іноді мають доступ інші люди, він хоче свторити пароль.  Обов'язково використовуйте щось що запам'ятовується або збережіть пароль десь, оскільки немає опції «скинути мій пароль». 

~~~
Enter same passphrase again:
~~~
{: .output}

Після введення того ж пароля вдруге ми отримуємо підтвердження

~~~
Your identification has been saved in /c/Users/Vlad Dracula/.ssh/id_ed25519
Your public key has been saved in /c/Users/Vlad Dracula/.ssh/id_ed25519.pub
The key fingerprint is:
SHA256:SMSPIStNyA00KPxuYu94KpZgRAYjgt9g4BA4kFy3g1o vlad@tran.sylvan.ia
The key's randomart image is:
+--[ED25519 256]--+
|^B== o.          |
|%*=.*.+          |
|+=.E =.+         |
| .=.+.o..        |
|....  . S        |
|.+ o             |
|+ =              |
|.o.o             |
|oo+.             |
+----[SHA256]-----+
~~~
{: .output}

"identification" насправді є приватним ключем. Ви ніколи не повинні ділитися ним. Відкритий ключ названий відповідним чином. "key fingerprint" 
є коротшою версією відкритого ключа.

Тепер, коли ми створили ключі SSH, ми знайдемо файли SSH при перевірці.

~~~
ls -al ~/.ssh
~~~
{: .language-bash}

~~~
drwxr-xr-x 1 Vlad Dracula 197121   0 Jul 16 14:48 ./
drwxr-xr-x 1 Vlad Dracula 197121   0 Jul 16 14:48 ../
-rw-r--r-- 1 Vlad Dracula 197121 419 Jul 16 14:48 id_ed25519
-rw-r--r-- 1 Vlad Dracula 197121 106 Jul 16 14:48 id_ed25519.pub
~~~
{: .output}

### 3.2 Копіювання відкритого ключа на GitHub
Тепер у нас є пара ключів SSH, і ми можемо запустити цю команду, щоб перевірити, чи може GitHub читати нашу автентифікацію.  

~~~
ssh -T git@github.com
~~~
{: .language-bash}


~~~
The authenticity of host 'github.com (192.30.255.112)' can't be established.
RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? y
Please type 'yes', 'no' or the fingerprint: yes
Warning: Permanently added 'github.com' (RSA) to the list of known hosts.
git@github.com: Permission denied (publickey).
~~~
{: .output}

Так, ми забули, що нам потрібно надати GitHub наш відкритий ключ!  

По-перше, нам потрібно скопіювати відкритий ключ.  Не забудьте включити «.pub» в кінці, в іншому випадку ви дивитеся на приватний ключ. 

~~~
cat ~/.ssh/id_ed25519.pub
~~~
{: .language-bash}

~~~
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIDmRA3d51X0uu9wXek559gfn6UFNF69yZjChyBIU2qKI vlad@tran.sylvan.ia
~~~
{: .output}

Тепер, перейшовши в GitHub.com, натисніть на значок профілю в правому верхньому куті, щоб отримати спадне меню.  Натисніть "Settings," потім на 
сторінці налаштувань, натисніть "SSH and GPG keys," ліворуч меню "Account settings".  Натисніть "New SSH key" кнопку з правого боку. Тепер, 
ви можете додати заголовок (Dracula використовує заголовок "Vlad's Lab Laptop", таким чином, він запам`ятає де розташовані оригінальні ключові пари файлів),
вставте SSH ключ в поле, і натисніть кнопку "Add SSH key", щоб завершити налаштування.

Тепер, коли ми встановили це, давайте перевіримо нашу аутентифікацію знову з командного рядка. 
~~~
$ ssh -T git@github.com
~~~
{: .language-bash}

~~~
Hi Vlad! You've successfully authenticated, but GitHub does not provide shell access.
~~~
{: .output}

Добре! Цей результат підтверджує, що ключ SSH працює за призначенням. Тепер ми готові завантажити нашу роботу до віддаленого репозиторію.

## 4. Завантаження локальних змін на віддалений репозиторій

Тепер, коли аутентифікація налаштована, ми можемо повернутися до віддаленого репозиторію.  Ця команда завантажить зміни з
нашого локального репозиторію до репозиторію на GitHub:

~~~
$ git push origin main
~~~
{: .language-bash}

Оскільки Dracula встановив парольну фразу, вона підкаже йому про це.  Якщо ви виконали додаткові налаштування для автентифікації, команда 
не запитає пароль. 

~~~
Enumerating objects: 16, done.
Counting objects: 100% (16/16), done.
Delta compression using up to 8 threads.
Compressing objects: 100% (11/11), done.
Writing objects: 100% (16/16), 1.45 KiB | 372.00 KiB/s, done.
Total 16 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), done.
To https://github.com/vlad/planets.git
 * [new branch]      main -> main
~~~
{: .output}

> ## Проксі-сервер
>
> Якщо мережа, до якої ви підключені, використовує проксі, є шанс, що ваша
> остання команда зазнала невдачі з "Could not resolve hostname" як повідомлення про помилку. Щоб
> вирішити це питання, потрібно розповісти Git про проксі:
>
> ~~~
> $ git config --global http.proxy http://user:password@proxy.url
> $ git config --global https.proxy https://user:password@proxy.url
> ~~~
> {: .language-bash}
>
> Коли ви підключаєтеся до іншої мережі, яка не використовує проксі, вам потрібно буде
> сказати Git відключити проксі за допомогою:
>
> ~~~
> $ git config --global --unset http.proxy
> $ git config --global --unset https.proxy
> ~~~
> {: .language-bash}
{: .callout}

> ## Менеджери паролів
>
> Якщо у вашій операційній системі налаштовано менеджер паролів, `git push`
> спробує використати його, коли йому потріне ім`я користувача і пароль.  Наприклад, це
> є типовою поведінкою для Git Bash на Windows. Якщо ви хочете ввести своє ім`я користувача
> та пароль в терміналі замість використання менеджера паролів,
> введіть:
>
> ~~~
> $ unset SSH_ASKPASS
> ~~~
> {: .language-bash}
>
> в терміналі, перед `git push`.  Незважаючи на ім`я, [Git використовує
> `SSH_ASKPASS` для всіх облікових
> записів](https://git-scm.com/docs/gitcredentials#_requesting_credentials), тож
> ви можете скасувати `SSH_ASKPASS` незважаючи на те, чи ви використовуєте Git через SSH або
> https.
>
> Ви також можете додати `unset SSH_ASKPASS` в кінці вашого `~/.bashrc`
> щоб зробити Git типовим для використання термінала для імен користувачів та паролів.
{: .callout}

Наші локальні та віддалені сховища зараз у такому стані:

![GitHub Repository After First Push]({{ site.baseurl }}/fig/github-repo-after-first-push.svg)

> ## Опція '-u'
>
> Ви можете побачити опцію «-u», який використовується з «git push» у деякій документації.  Ця
> опція є синонімом опції `--set-upstream-to` для команди `git branch`
>  і використовується для зв`язку поточної гілки з віддаленою гілкою так, що
> команда `git pull` може будти використана без будь-яких аргументів. Щоб зробити це,
> просто використайте `git push -u origin main` після налаштування пульта дистанційного керування.
{: .callout}

Ми також можемо переносити зміни з віддаленого сховища на локальний:

~~~
$ git pull origin main
~~~
{: .language-bash}

~~~
From https://github.com/vlad/planets
 * branch            main     -> FETCH_HEAD
Already up-to-date.
~~~
{: .output}

Перетягування не має ніякого ефекту в цьому випадку, тому що два сховища вже
синхронізовані.  Якщо хтось ще завантажив якісь зміни до репозиторію на
GitHub, хоч ця команда завантажить їх у наш локальний репозиторій.

> ## GitHub GUI
>
> Перегляньте ваш репозиторій `planets` на GitHub.
> Під вкладкою Code, знайдіть та натисніть на текст, який говорить "XX commits" (де "XX" це якесь число).
> Наведіть курсор і натисніть на три кнопки праворуч від кожного коміту.
> Яку інформацію ви можете зібрати/вивчити з цих кнопок?
> Як би ви отримали ту саму інформацію в shell?
>
> > ## Відповідь
> > Ліва кнопка (з зображенням буфера обміну) копіює повний ідентифікатор коміту 
> > в буфер обміну. В shell, ```git log``` покаже вам повний ідентифікатор коміту для кожного 
> > коміту.
> >
> > Коли ви натиснете на середню кнопку, ви побачите всі зміни, які були зроблені в цьому 
> > конкретному коміті. Зелені затінені лінії вказують на додавання та видалення червоних. В shell ми 
> > можемо зробити ту саму річ з ```git diff```. А саме, ```git diff ID1..ID2```, де ID1 та 
> > ID2 ідентифікатори комітів (наприклад, ```git diff a3bf1e5..041e637```) покаже відмінності 
> > між двома комітами.
> >
> > Найправіша кнопка дозволяє переглядати всі файли в сховищі під час цього
> > коміту. Для того, щоб зробити це в shell, нам потрібно було б перевірити репозиторій в той конкретний час. 
> > Ми можемо зробити це за допомогою ```git checkout ID```, де ID - ідентифікатор коміту, на який ми хочемо подивитися. 
> > Якщо ми зробимо це, нам потрібно пам`ятати про повернення репозиторію в потрібний стан
> > після цього! 
> {: .solution}
{: .challenge}

> ## Завантаження файлів безпосередньо в браузері GitHub
>
> Github також дозволяє нам пропустити командний рядок ізавантажити файли безпосередньо до 
> вашого репозиторію без необхідності залишати браузер. Є два варіанти. 
> Перший - ви можете натиснути кнопку "Upload files" на панелі інструментів у верхній частині
> дерева файлів. Або, можна перетягувати файли з робочого стору до дерева файлівю 
> Ви можете більше прочитати про це [на цій GitHub сторінці](https://help.github.com/articles/adding-a-file-to-a-repository/)
{: .callout}

> ## Часова Мітка GitHub
>
> Створіть віддалений репозиторій на GitHub. Відправте  вміст вашого локального сховища
> до віддаленого. Внесіть зміни до вашого локального сховища та відправте ці зміни.
> Перейдіть до щойно створеного на GitHub репо і перевірте
> [часові мітки]({{ page.root }}{% link reference.md %}#timestamp) файлів. Як GitHub
> записує час і чому?
>
> > ## Відповідь
> > GitHub відображає мітки часу у відносному форматі, що читається людиною (наприклад, "22 години назад" або "три 
> > тижні тому"). Однак, якщо ви наведете курсор на мітку часу, ви можете побачити точний час, в який
> > остання зміна файлу відбулася. 
> {: .solution}
{: .challenge}

> ## Відправлення змін vs. Коміт
>
> В цьому епізоді, ми познайомилися з командою "git push".
> Як "git push" відрізняється "git commit"?
>
> > ## Відповідь
> > Коли ми відправляємо зміни, ми взаємодіємо з віддаленим репозиторієм, щоб оновити його зі змінами, 
> > ми зробили локально (часто це відповідає обміну змінами, які ми зробили з іншими). 
> > Commit оновлює лише локальний репозиторій.
> {: .solution}
{: .challenge}

> ## GitHub Ліцензія та файли README
>
> У цьому епізоді ми дізналися про створення віддаленого репозиторію на GitHub, але коли ми ініціалізували наш 
> GitHub репо, ми не додали README.md або файл ліцензії. Якщо б ми це зробили, що, на вашу думку, 
> сталося б, коли ми намагалися зв`язати локальні та віддалені репозиторії?
>
> > ## Відповідь
> > У цьому випадку ми побачимо конфлікт злиття через неспоріднені історії. Коли GitHub створює 
> > README.md файл, він виконує коміт у віддаленому репозиторії. Коли ви намагаєтеся витягнути віддалений 
> > репозиторій до вашого локального репозиторію, Git виявляє, що у них є історії, які не мають спільного
> > походження і відмовляється від злиття..
> > ~~~
> > $ git pull origin main
> > ~~~
> > {: .language-bash}
> >
> > ~~~
> > warning: no common commits
> > remote: Enumerating objects: 3, done.
> > remote: Counting objects: 100% (3/3), done.
> > remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
> > Unpacking objects: 100% (3/3), done.
> > From https://github.com/vlad/planets
> >  * branch            main     -> FETCH_HEAD
> >  * [new branch]      main     -> origin/main
> > fatal: refusing to merge unrelated histories
> > ~~~
> > {: .output}
> >
> > Ви можете змусити git об'єднати два сховища з опцією `--allow-unrelated-histories`. 
> > Будьте обережні, коли ви використовуєте цей параметр і уважно вивчіть вміст локальних і віддалених 
> > репозиторіїв перед об'єднанням..
> > ~~~
> > $ git pull --allow-unrelated-histories origin main
> > ~~~
> > {: .language-bash}
> >
> > ~~~
> > From https://github.com/vlad/planets
> >  * branch            main     -> FETCH_HEAD
> > Merge made by the 'recursive' strategy.
> > README.md | 1 +
> > 1 file changed, 1 insertion(+)
> > create mode 100644 README.md
> > ~~~
> > {: .output}
> {: .solution}
{: .challenge}

