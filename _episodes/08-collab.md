---
title: Співпраця
teaching: 25
exercises: 0
questions:
- "Як я можу використовувати контроль версій для співпраці з іншими людьми?"
objectives:
- "Клонування віддаленого сховища."
- "Співпрацювати, відправляюючи зміни до загального репозиторію."
- "Опишіть базовий спільний робочий процес."
keypoints:
- "`git clone` копіює віддалений репозиторій для створення локального репозиторію за допомогою автоматичного налаштування віддаленого «origin»."
---

На наступний крок поділіться на пари.  Одна людина буде «Власником», а інша
буде «Співавтор». Мета полягає в тому, щоб Співавтор додав зміни в репозиторій
Власника. Ми поміняємося ролями в кінці так, щоб обидві людини будуть
грати Власника та Співавтора.

> ## Самостійна Практика
>
> Якщо ви працюєте над цим уроком самостійно, ви можете продовжити, відкривши
> друге вікно терміналу.
> Це вікно буде представляти вашого партнера, який працює на іншому комп'ютері. Вам
> не потрібно буде надавати нікому доступ до GitHub, тому що обидва «партнери» - це ви.
{: .callout}

Власник повинен надати співробітнику доступ. В GitHub, праворуч натисніть кнопку "Settings",
виберіть "Collaborators", натисніть "Add people", та
потім введіть ім`я вашого партнера.

![Adding Collaborators on GitHub](../fig/github-add-collaborators.png)

Щоб прийняти доступ до репо Власника, Співробітнику
потрібно перейти до [https://github.com/notifications](https://github.com/notifications) 
або перевірити або перевірити наявність сповіщення електронною поштою. Після цього вона може прийняти доступ до репо власника.

Далі, Колаборант повинен завантажити копію репозиторію Власника на його
комп`ютер. Це називається "клонування репо". 

Колаборант не хоче перезаписувати власну версію `planets.git`, тому 
потрібно клонувати сховище Власника в інше місце, ніж його власний 
репозиторій з такою ж назвою.

Щоб клонувати репо Власника в папку `Desktop`, Колаборант вводить:

~~~
$ git clone git@github.com:vlad/planets.git ~/Desktop/vlad-planets
~~~
{: .language-bash}

Замініть 'vlad' на ім`я користувача Власника.

Якщо ви вирішите клонувати без шляху клонування
(`~/Desktop/vlad-planets`) вказаного в кінці,
ви будете клонувати всередині вашої власної папки планет!
Переконайтеся, що спочатку ви перейшли до папки `Desktop`.

![Після створення клону репозиторію](../fig/github-collaboration.svg)

Колаборант тепер може змінити свій клон репозиторію Власника
точно так само, як ми робили раніше:

~~~
$ cd ~/Desktop/vlad-planets
$ nano pluto.txt
$ cat pluto.txt
~~~
{: .language-bash}

~~~
It is so a planet!
~~~
{: .output}

~~~
$ git add pluto.txt
$ git commit -m "Add notes about Pluto"
~~~
{: .language-bash}

~~~
 1 file changed, 1 insertion(+)
 create mode 100644 pluto.txt
~~~
{: .output}

Далі відправте зміни до *репозиторію Власника* на GitHub:

~~~
$ git push origin main
~~~
{: .language-bash}

~~~
Enumerating objects: 4, done.
Counting objects: 4, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 306 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/vlad/planets.git
   9272da5..29aba7c  main -> main
~~~
{: .output}

Зауважте, що нам не потрібно було створювати віддалений репозиторій під назвою `origin`: Git використовує цю
цю назву за замовчуванням, коли ми клонуємо репозиторій.  (Ось чому `origin` був
розумним вибором раніше, коли ми налаштовували віддалені репозиторії вручну.)

Знову подивіться на репозиторій Власника на GitHub, і ви повинні
бачити новий коміт, зроблений Колаборантом. Можливо, вам доведеться оновити
ваш браузер, щоб побачити новий коміт.

> ## Дещо більше про віддалені репозиторії
>
> У цьому епізоді і попередньому, наш локальний репозиторій мав
> єдиний "віддалений" репозиторій, під назвою `origin`. Віддалений - це копія репозиторію,
> яка знаходиться в іншому місці, яку ми можемо відправити і отримати, 
> і немає причин працювати тільки з одним. Наприклад, 
> у деяких великих проєктах у вас може бути власна копія у вашому власному обліковому записі GitHub
> (ви, ймовірно, називаєте її `origin`), а також головне сховище проєктів "upstream"
> (давайте назвемо це «upstream» заради прикладів).
> Час від часу ви будете отримувати зміни з `upstream`, 
> щоб отримати останні оновлення, які зробили інші люди.
>
> Пам'ятайте, що ім'я, яке ви надаєте віддаленому репозиторію, існує лише локально. Це 
> псевдонім, який ви вибираєте - будь то `origin`, чи `upstream`, чи `fred` -
> а не щось притаманне віддаленому репозиторію.
>
> Сімейство команд `git remote` використовується для налаштування та зміни пультів, 
> пов'язаних з репозиторієм. Ось деякі з найбільш корисних:
>
> * `git remote -v` перераховує всі віддалені репозиторії, які налаштовані (ми вже використовували 
> це в останньому епізоді)
> * `git remote add [name] [url]` використовується для додавання нового віддаленого репозиторію
> * `git remote remove [name]` видаляє пульт дистанційного керування. Зауважте, що це взагалі не впливає на 
> віддалений репозиторій - він просто видаляє посилання на нього з локального репозиторію.
> * `git remote set-url [name] [newurl]` змінює URL, який пов`язаний з 
> віддаленим репозиторієм. Це корисно, якщо він перейшов, наприклад, на інший обліковий запис GitHub
> або з GitHub на інший хостинг. Або, якщо ми зробили помилку при
> його додаванні!
> * `git remote rename [oldname] [newname]` змінює місцевий псевдонім, за яким відомий 
> віддалений - його назву. Наприклад, можна використовувати це, щоб змінити `upstream` на `fred`.
{: .callout}

Щоб завантажити зміни Колаборанта з GitHub, Власник тепер вводить:

~~~
$ git pull origin main
~~~
{: .language-bash}

~~~
remote: Enumerating objects: 4, done.
remote: Counting objects: 100% (4/4), done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
From https://github.com/vlad/planets
 * branch            main     -> FETCH_HEAD
   9272da5..29aba7c  main     -> origin/main
Updating 9272da5..29aba7c
Fast-forward
 pluto.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 pluto.txt
~~~
{: .output}

Тепер три сховища (локальний Власника, локальний Колаборанта і Власника на
GitHub) знову синхронізуються.

> ## Базовий Спільний Робочий Процес
>
> На практиці добре бути впевненим, що у вас є оновлена версія репозиторію,
> з яким ви співпрацюєте, тому перед внесенням наших змін слід зробити `git pull`
> Основним спільним робочим процесом буде:
>
> * оновити локальне репо за допомогою `git pull origin main`,
> * внести свої зміни і перенети їх в зону стейджингу за допомогою `git add`,
> * закомітити зміни за допомогою `git commit -m`, та
> * завантажити зміни на GitHub з `git push origin main`
>
> Краще зробити багато комітів з меншими змінами, ніж
> один коміт з масивними змінами: маленькі коміти легше
> читати та переглядати.
{: .callout}

> ## Зміна Ролей і Повторення
>
> Поміняйтеся ролями та повторіть весь процес.
{: .challenge}

> ## Перегляд Змін
>
> Власник відправив коміти до репозиторію без надання будь-якої інформації
> Клаборанту. Як Колаборант може дізнатися, що змінилося з
> командним рядком? А на GitHub?
>
> > ## Відповідь
> > В командному рядку, Колаборант може використати ```git fetch origin main```
> > щоб отримати віддалені зміни в локальному репозиторії, але без їх 
> > об'єднання. Потім запускаючи ```git diff main origin/main```, tКолаборант
> > побачить результат змін у терміналі.
> >
> > В GitHub, Колаборант може перейти в репозиторій і натиснути на 
> > "commits", щоб переглянути найновіші коміти, що надсилаються до репозиторію.
> {: .solution}
{: .challenge}

> ## Коментування Змін в GitHub
>
> У Колаборанта є деякі питання про зміни в одній лінії, зроблені Власником, і
> він має деякі пропозиції.
>
> З GitHub можна коментувати різницю коміту.  По лінії коду
> для коментування, з'явиться синій значок коментаря, щоб відкрити вікно коментаря.
>
> Колаборант публікує свої коментарі та пропозиції за допомогою інтерфейсу GitHub.
{: .challenge}

> ## Історія версій, Резервне Копіювання та Контроль Версій
>
> Деякі програми резервного копіювання можуть зберігати історію версій ваших файлів. Вони також
> дозволяють відновити певні версії. Чим цей функціонал відрізняється від контролю версій?
> Які переваги використання контролю версій, Git і GitHub?
{: .challenge}

